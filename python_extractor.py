import ast
import datetime
import os
from copy import deepcopy
from typing import Union, Dict
import black
import hashlib

from langchain_community.llms.ollama import Ollama
from langchain_core.prompts import ChatPromptTemplate


class PythonExtractor:
    def __init__(self, root_directory: str | os.PathLike):
        self.root_directory = root_directory

        self.template_message = 'This is an autogenerated docstring'

        self.ai_documenter = AIDocumenter()

    def extract_classes_and_functions(self, file_content):
        """
        Extract classes and functions from the provided Python file content.

        Args:
            file_content (str): The content of the Python file.

        Returns:
            dict: A dictionary with class and function names as keys and their definitions as values.
        """
        tree = ast.parse(file_content)
        result = {"classes": [], "functions": []}

        for node in ast.walk(tree):
            data = {}

            if isinstance(node, (ast.ClassDef, ast.FunctionDef)):
                data['source'] = ast.get_source_segment(file_content, node)
                data['doc'] = ast.get_docstring(node)
                data['node'] = node

                type = 'classes' if isinstance(node, ast.ClassDef) else 'functions'
                data['type'] = type

                result[type].append(data)

        return tree, result

    def read_file(self, file_path):
        """
        Read the content of a file.

        Args:
            file_path (str): The path to the file.

        Returns:
            str: The content of the file.
        """
        with open(file_path, "r") as file:
            return file.read()

    def find_python_files(self, folder_path):
        """
        Find all Python files in the specified folder and its subfolders.

        Args:
            folder_path (str): The path to the folder.

        Returns:
            list: A list of file paths to Python files.
        """
        python_files = []
        for root, _, files in os.walk(folder_path):
            for file in files:
                if file.endswith(".py"):
                    python_files.append(os.path.join(root, file))
        return python_files

    def get_docstring(self, node: Union[ast.ClassDef, ast.FunctionDef]):
        """
        Get the docstring of a given AST node.

        Args:
            node (ast.AST): The AST node to extract the docstring from.

        Returns:
            str: The extracted docstring or an empty string if not present.
        """
        return ast.get_docstring(node)

    def set_docstring(self, node: Union[ast.ClassDef, ast.FunctionDef], docstring):
        """
        Set the docstring for a given AST node.

        Args:
            node (ast.AST): The AST node to set the docstring for.
            docstring (str): The docstring to set.
        """
        docstring_node = ast.Expr(value=ast.Constant(value=docstring))
        node.body.insert(0, docstring_node)

    def update_docstring(self, node: Union[ast.ClassDef, ast.FunctionDef], docstring):
        """
        Update the docstring for a given AST node.

        Args:
            node (ast.AST): The AST node to set the docstring for.
            docstring (str): The docstring to set.
        """
        docstring_node = ast.Expr(value=ast.Constant(value=docstring))
        node.body[0] = docstring_node

    def extract(self):
        """
        Main function to find Python files in the folder and extract classes and functions.

        Args:
            folder_path (str): The path to the folder.
        """
        python_files = self.find_python_files(self.root_directory)

        for file_path in python_files:
            print(f"\nProcessing file: {file_path}")
            file_content = self.read_file(file_path)

            tree, extracted_content = self.extract_classes_and_functions(file_content)

            modified = False

            for class_node in extracted_content['classes']:
                print(f"\nClass: {class_node['node'].name}")
                modified = self.generate_doc(class_node)

            for func_node in extracted_content["functions"]:
                print(f"\nClass: {func_node['node'].name}")
                modified = self.generate_doc(func_node)

            if modified:
                new_content = ast.unparse(tree)
                self.write_file(file_path, new_content)

    def write_file(self, file_path, content):
        """
        Write content to a file.

        Args:
            file_path (str): The path to the file.
            content (str): The content to write.
        """
        with open(file_path, "w") as file:
            file.write(content)

    def generate_func_hash(self, node: ast.AST, has_documentation=False):

        if has_documentation:
            node: ast.AST = deepcopy(node)
            # Remove the documentation when generating the hash, you only care about the contents of the function
            node: Union[ast.ClassDef, ast.FunctionDef]

            del node.body[0]

        # Convert the AST node to a string representation
        node_str = ast.dump(node)

        # Create a SHA-256 hash object
        hash_object = hashlib.sha256()

        # Update the hash object with the bytes of the node string
        hash_object.update(node_str.encode('utf-8'))

        # Return the hexadecimal digest of the hash
        return hash_object.hexdigest()

    def generate_doc(self, node: Dict):
        class_node: Union[ast.ClassDef, ast.FunctionDef] = node['node']

        node_type: str = node['type']



        documentation = self.get_docstring(class_node)

        hash = self.generate_func_hash(class_node, has_documentation=not (documentation is None))

        modified = False

        if documentation and self.template_message in documentation:
            if  node_type == 'functions':

                previous_hash = documentation.split(' ')[-1].strip()

                if not (previous_hash is hash):
                    print(
                        "There is a hash mismatch between the function and the last time the documentation for it was generated.")

                text = self.api_find_docstring(node)

                text = self.parse_doc(text, hash)


                self.update_docstring(class_node, text)

                modified =  True
        if not documentation:
            text = self.api_find_docstring(node)
            text = self.parse_doc(text, hash)

            self.set_docstring(class_node, text)

            modified = True

        return modified

    def parse_doc(self, text:str, hash:str):

        return os.linesep.join([
            text,
            self.template_message,
            f'hash {hash}'
        ])



    def api_find_docstring(self, node):
        docstring = self.ai_documenter(node['source'])

        print(docstring)

        return docstring


class AIDocumenter:
    def __init__(self):
        model = Ollama(model="dolphin-mistral")

        function_documentation_template = """
            Given the following Python function or Class, generate comprehensive documentation including a description, parameters, and return value in reStructredText format.

            Function:
            {function}

            Documentation:
            """

        prompt = ChatPromptTemplate.from_messages(
            [
                (
                    "system",
                    function_documentation_template,
                )
            ]
        )

        self.function_chain = prompt | model

    def __call__(self, function_source: str):
        response = self.function_chain.invoke(
            {"function": function_source}
        )

        return response


if __name__ == '__main__':
    data = PythonExtractor('codebases/apecs_library')

    data.extract()
