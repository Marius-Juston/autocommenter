import ast
import hashlib
import os
from copy import deepcopy
from typing import Union, Dict

import black
from langchain_community.llms.ollama import Ollama
from langchain_core.prompts import ChatPromptTemplate


class PythonExtractor:
    def __init__(self, root_directory: str | os.PathLike):
        self.root_directory = root_directory

        self.template_message = 'This is an autogenerated docstring'

        self.ai_documenter = AIDocumenter()

    def extract_classes_and_functions(self, file_content):
        """
        Extract classes and functions from the provided Python file content.

        Args:
            file_content (str): The content of the Python file.

        Returns:
            dict: A dictionary with class and function names as keys and their definitions as values.
        """
        tree = ast.parse(file_content)
        result = {"classes": [], "functions": []}

        for node in ast.walk(tree):
            data = {}

            if isinstance(node, (ast.ClassDef, ast.FunctionDef)):
                data['source'] = ast.get_source_segment(file_content, node)
                data['doc'] = ast.get_docstring(node)
                data['node'] = node

                type = 'classes' if isinstance(node, ast.ClassDef) else 'functions'
                data['type'] = type

                result[type].append(data)

        return tree, result

    def read_file(self, file_path):
        """
        Read the content of a file.

        Args:
            file_path (str): The path to the file.

        Returns:
            str: The content of the file.
        """
        with open(file_path, "r") as file:
            return file.read()

    def find_python_files(self, folder_path):
        """
        Find all Python files in the specified folder and its subfolders.

        Args:
            folder_path (str): The path to the folder.

        Returns:
            list: A list of file paths to Python files.
        """
        python_files = []
        for root, _, files in os.walk(folder_path):
            for file in files:
                if file.endswith(".py"):
                    python_files.append(os.path.join(root, file))
        return python_files

    def get_docstring(self, node: Union[ast.ClassDef, ast.FunctionDef]):
        """
        Get the docstring of a given AST node.

        Args:
            node (ast.AST): The AST node to extract the docstring from.

        Returns:
            str: The extracted docstring or an empty string if not present.
        """
        return ast.get_docstring(node)

    def set_docstring(self, node: Union[ast.ClassDef, ast.FunctionDef], docstring):
        """
        Set the docstring for a given AST node.

        Args:
            node (ast.AST): The AST node to set the docstring for.
            docstring (str): The docstring to set.
        """
        docstring_node = ast.Expr(value=ast.Constant(value=docstring))
        node.body.insert(0, docstring_node)

    def update_docstring(self, node: Union[ast.ClassDef, ast.FunctionDef], docstring):
        """
        Update the docstring for a given AST node.

        Args:
            node (ast.AST): The AST node to set the docstring for.
            docstring (str): The docstring to set.
        """
        docstring_node = ast.Expr(value=ast.Constant(value=docstring))
        node.body[0] = docstring_node

    def extract(self):
        """
        Main function to find Python files in the folder and extract classes and functions.

        Args:
            folder_path (str): The path to the folder.
        """
        python_files = self.find_python_files(self.root_directory)

        for file_path in python_files:
            print(f"\nProcessing file: {file_path}")
            file_content = self.read_file(file_path)

            tree, extracted_content = self.extract_classes_and_functions(file_content)

            modified = False

            for class_node in extracted_content['classes']:
                print(f"\nClass: {class_node['node'].name}")
                modified = modified or self.generate_doc(class_node)

            for func_node in extracted_content["functions"]:
                print(f"\nFunction: {func_node['node'].name}")
                modified = modified or self.generate_doc(func_node)

            if modified:
                new_content = ast.unparse(tree)

                formatted_new_content = black.format_str(new_content, mode=black.Mode())

                self.write_file(file_path, formatted_new_content)

    def write_file(self, file_path, content):
        """
        Write content to a file.

        Args:
            file_path (str): The path to the file.
            content (str): The content to write.
        """
        with open(file_path, "w") as file:
            file.write(content)

    def generate_func_hash(self, node: ast.AST, has_documentation=False):

        if has_documentation:
            node: ast.AST = deepcopy(node)
            # Remove the documentation when generating the hash, you only care about the contents of the function
            node: Union[ast.ClassDef, ast.FunctionDef]

            del node.body[0]

        # Convert the AST node to a string representation
        node_str = ast.dump(node)

        # Create a SHA-256 hash object
        hash_object = hashlib.sha256()

        # Update the hash object with the bytes of the node string
        hash_object.update(node_str.encode('utf-8'))

        # Return the hexadecimal digest of the hash
        return hash_object.hexdigest()

    def generate_doc(self, node: Dict):
        class_node: Union[ast.ClassDef, ast.FunctionDef] = node['node']

        node_type: str = node['type']

        documentation = self.get_docstring(class_node)

        hash = self.generate_func_hash(class_node, has_documentation=not (documentation is None))

        modified = False

        if documentation and self.template_message in documentation:
            if node_type == 'functions':

                previous_hash = documentation.split(' ')[-1].strip()

                if not (previous_hash == hash):
                    print(
                        "There is a hash mismatch between the function and the last time the documentation for it was generated.")

                    text = self.api_find_docstring(node)

                    text = self.parse_doc(text, hash)

                    self.update_docstring(class_node, text)

                    modified = True
        if not documentation:
            text = self.api_find_docstring(node)
            text = self.parse_doc(text, hash)

            self.set_docstring(class_node, text)

            modified = True

        return modified

    def parse_doc(self, text: str, hash: str):

        return os.linesep.join([
            "",
            text,
            self.template_message,
            f'hash {hash}',
            ""
            ""
        ])

    def api_find_docstring(self, node):
        docstring = self.ai_documenter(node['source'], node['type'])

        print(docstring)

        return docstring


class AIDocumenter:
    def __init__(self):
        # model = Ollama(model="dolphin-mistral")
        model = Ollama(model="codestral")

        function_documentation_template = """
            Write comprehensive documentation for the following Python code using reStructuredText (reST) format. The documentation should include a description, parameter explanations, return type, and examples. Ensure the documentation is clear, concise, and follows standard conventions.

Example output:
Function Name
=============

Description
-----------
<Brief description of the function's purpose.>

Parameters
----------
- **a** (*int*): <Explanation of the first parameter.>
- **b** (*int*): <Explanation of the second parameter.>

Returns
-------
- **int**: <Explanation of the return type.>

Examples
--------
.. code-block:: python

    <Example 1>

    <Example 2>

Notes
-----
<Any additional notes or caveats.>


            Function:
            {function}

            Documentation:
            """

        class_documentation_template = """
                    Write comprehensive header documentation for the following Python class using reStructuredText (reST) format. The documentation should include a description, attribute explanations, method summaries, inheritance diagrams, and examples. Ensure the documentation is clear, concise, and follows standard conventions.

        Class Name
==========

Description
-----------
<Brief description of the class's purpose.>

Attributes
----------
- **attribute_name** (*type*): <Explanation of the attribute.>

Methods
-------
- **method_name(parameters)**: <Brief description of the method.>

Inheritance Diagram
-------------------
.. inheritance-diagram:: module.ClassName
   :parts: 1

Examples
--------
.. code-block:: python

    <Example 1>

    <Example 2>

Notes
-----
<Any additional notes or caveats.>

                    Class:
                    {function}

                    Documentation:
                    """

        func_prompt = ChatPromptTemplate.from_messages(
            [
                (
                    "system",
                    function_documentation_template,
                )
            ]
        )

        class_prompt = ChatPromptTemplate.from_messages(
            [
                (
                    "system",
                    class_documentation_template,
                )
            ]
        )

        self.function_chain = func_prompt | model
        self.class_chain = class_prompt | model

        self.chain = {'functions': self.function_chain, 'classes': self.class_chain}

    def normalize_left_strip(self, txt: str):
        lines = txt.split(os.linesep)

        line_strip = None

        for line in lines:
            lines_stripped = line.lstrip()

            for mixes in ['====', '----']:
                if lines_stripped.startswith(mixes):
                    index = line.find(mixes)

                    if line_strip:
                        line_strip = min(index, line_strip)
                    else:
                        line_strip = index

        for i in range(len(lines)):
            first_char = lines[i].lstrip()

            if len(first_char) == 0:
                continue

            text_index = lines[i].find(first_char[0])

            max_stripping = min(line_strip, text_index)

            lines[i] = lines[i][max_stripping:]

        return os.linesep.join(lines)

    def __call__(self, function_source: str, type: str):

        response = self.chain[type].invoke(
            {"function": function_source}
        ).strip()

        response = self.normalize_left_strip(response)

        return response


if __name__ == '__main__':
    data = PythonExtractor('codebases/apecs_library')

    data.extract()
